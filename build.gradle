plugins {
    id 'cpp'
    id 'google-test-test-suite'
}

// assume a path is absolute if it starts with '/', and relative to the project
// if it does not
def validate_project_settings() {
    if(!optix_location.startsWith("/")) {
        optix_location = "${projectDir.getPath()}/${optix_location}"
    }
    if(!cuda_location.startsWith("/")) {
        cuda_location = "${projectDir.getPath()}/${cuda_location}"
    }
    if(!mdl_location.startsWith("/")) {
        mdl_location = "${projectDir.getPath()}/${mdl_location}"
    }
    if(!googletest_location.startsWith("/")) {
        googletest_location = "${projectDir.getPath()}/${googletest_location}"
    }
}

validate_project_settings()

model {
    repositories {
        libs(PrebuiltLibraries) {
            googleTest {
                headers.srcDirs "${googletest_location}/include"
                binaries.withType(StaticLibraryBinary) {
                    staticLibraryFile = file("${googletest_location}/build/libgtest.a")
                }
            }
            optix {
                headers.srcDirs "${optix_location}/include"
                binaries.withType(SharedLibraryBinary) {
                    sharedLibraryFile = file("${optix_location}/lib64/liboptix.so.6.0.0")
                }
            }
            cuda {
                headers.srcDirs "${cuda_location}/include"
                binaries.withType(SharedLibraryBinary) {
                    sharedLibraryFile = file("${cuda_location}/lib64/libcudart.so")
                }
                binaries.withType(StaticLibraryBinary) {
                    staticLibraryFile = file("${cuda_location}/lib64/libcudart_static.a")
                }
            }
        }
    }
    components {
        raytrace(NativeLibrarySpec) {
            sources.cpp.lib library: 'cuda', linkage: 'shared'
            sources.cpp.lib library: 'optix', linkage: 'shared'
        }
        rayterm(NativeLibrarySpec) {
            sources.cpp.lib library: 'cuda', linkage: 'shared'
            sources.cpp.lib library: 'optix', linkage: 'shared'
            sources.cpp.lib library: 'raytrace', linkage: link_type
        }
        rtexplore(NativeExecutableSpec) {
            sources.cpp.lib library: 'cuda', linkage: 'shared'
            sources.cpp.lib library: 'optix', linkage: 'shared'
            sources.cpp.lib library: 'raytrace', linkage: link_type
            sources.cpp.lib library: "rayterm", linkage: link_type
        }
    }
    testSuites {
        raytraceTest(GoogleTestTestSuiteSpec) {
            testing $.components.raytrace
            sources.cpp.source.srcDir "src/raytrace/test"
            sources.cpp.lib library: 'cuda', linkage: 'shared'
            sources.cpp.lib library: 'optix', linkage: 'shared'
        }
        raytermTest(GoogleTestTestSuiteSpec) {
            testing $.components.raytrace
            sources.cpp.source.srcDir "src/rayterm/test"
            sources.cpp.lib library: 'raytrace', linkage: link_type
            sources.cpp.lib library: 'cuda', linkage: 'shared'
            sources.cpp.lib library: 'optix', linkage: 'shared'
        }
    }
    binaries {
        all {
            linker.args "-lncurses"
            if(project.hasProperty('SAMPLES'))
                cppCompiler.define "SAMPLES", "${project.getProperty('SAMPLES')}"
            if(project.hasProperty('RES_MULT'))
                cppCompiler.define "RES_MULT", "${project.getProperty('RES_MULT')}"
            if(project.hasProperty('NO_PROGRESS'))
                cppCompiler.define "NO_PROGRESS"

            cppCompiler.args "-std=c++11", "-msse4", "-fPIC", "-Wall"
            setCuArgs(cppCompiler)

            if (buildType == buildTypes.debug) {
                cppCompiler.args "-g"
            } else if(buildType == buildTypes.release) {
                cppCompiler.args "-O3", "-funroll-loops", "-march=native", "-mfpmath=sse"
            }
        }
        withType(GoogleTestTestSuiteBinarySpec) {
            lib library: "googleTest", linkage: "static"
            // assumes linux
            cppCompiler.args '-pthread'
            linker.args '-pthread'
        }
    }
    buildTypes {
        debug
        release
    }
    platforms {
        x64 {
            architecture "x86_64"
        }
    }
    // gcc/g++ 7 is required for cuda, but no way to ensure that
    // is kept currently, except to manually set executable, and
    // hope gradle can find it. The path variable can help.
    toolChains {
        gcc(Gcc) {
            // path "/usr/bin/"
            eachPlatform { tools ->
                tools.cppCompiler.executable = "g++-7"
            }
        }
    }
}

def getCuFiles() {
    return fileTree("src").matching { it.include("**/*.cu") }.files
}

def getPTXFolder() {
    if(ptx_folder.startsWith("/")) {
        return file(ptx_folder)
    }
    return file("${project.buildDir}/${ptx_folder}")
}

def setCuArgs(cppCompiler) {
    cppCompiler.define "PROGRAM_DIRECTORY", "\"${getPTXFolder().path}\""

    def files = []
    getCuFiles().each { file -> files.add("\"${file.name - ~/\.cu$/}\"") }

    cppCompiler.define "PROGRAM_LIST", "{${files.join ", "}}"
}

task compileCu() {

    def ptxFolder = getPTXFolder();
    def cuFiles = getCuFiles()

    doFirst {
        ptxFolder.mkdirs();
    }

    cuFiles.each { file -> inputs.file file }
    outputs.dir ptxFolder

    doLast {
        cuFiles.each { file ->
            def dest = "${getPTXFolder()}/${file.name - ~/\.cu$/}.ptx"
            println "${file.path} -> ${dest}"
            exec {
                executable "${cuda_location}/bin/nvcc"
                args "-I${optix_location}/include"
                args "-I${cuda_location}/include"
                args "-ptx", "-o", dest
                args file.path
            }
        }
    }
}

build.dependsOn 'compileCu'
build.mustRunAfter 'compileCu'


task lintMDL(type: Exec) {
    doFirst { println "--- mdl ---" }

    def reportDir = file("${buildDir}/lint-results")
    def report = file("${buildDir}/lint-results/mdl.xml")

    executable "mdl"
    args "README.md"

    inputs.file file("README.md")
    outputs.dir reportDir
    outputs.file report

    doLast { println "--- --- ---" }
    doLast {
        reportDir.mkdirs()
        report.createNewFile()
    }
}

task lintProselint(type: Exec) {
    doFirst { println "--- proselint ---" }

    def reportDir = file("${buildDir}/lint-results")
    def report = file("${buildDir}/lint-results/proselint.xml")

    executable "proselint"
    args "README.md"

    inputs.file file("README.md")
    outputs.dir reportDir
    outputs.file report

    doLast { println "--- ---- ---- ---" }
    doLast {
        reportDir.mkdirs()
        report.createNewFile()
    }
}

task lintClangTidy(type: Exec) {
    doFirst { println "--- clang-tidy ---" }

    executable "clang-tidy"

    // collect all .cpp files (headers are taken from include directories)
    def cppFiles = fileTree("src").matching { it.include("**/*.cpp") }.files
    def reportDir = file("${buildDir}/lint-results")
    def report = file("${buildDir}/lint-results/clangtidy.xml")

    cppFiles.each { file -> inputs.file file }
    outputs.dir reportDir
    outputs.file report

    def ptr_stuff = ",-clang-analyzer-cplusplus.NewDelete,-clang-analyzer-cplusplus.InnerPointer,-clang-analyzer-cplusplus.NewDeleteLeaks"

    args cppFiles.path
    args "-checks=-*,google-*,modernize-*,clang-analyzer-*,bugprone-*,performance-*$ptr_stuff"
    args "-warnings-as-errors=-*,google-*,modernize-*,clang-analyzer-*,bugprone-*,performance-*"
    args "-header-filter=src/.*"
    args "--"
    args "-I${googletest_location}/include"
    args "-I${optix_location}/include"
    args "-I${cuda_location}/include"
    args "-Isrc/rayterm/headers"
    args "-Isrc/raytrace/headers"
    args "-std=c++11", "-msse4", "-fPIC", "-Wall", "-O3", "-funroll-loops", "-march=native", "-mfpmath=sse"

    doLast { println "--- ----  ---- ---" }

    doLast {
        reportDir.mkdirs()
        report.createNewFile()
    }

    // lint writing first -- it's faster
    shouldRunAfter 'lintMDL'
    shouldRunAfter 'lintProselint'
}

check.finalizedBy 'lintClangTidy'
check.finalizedBy 'lintMDL'
check.finalizedBy 'lintProselint'

task lint {
    dependsOn 'lintClangTidy'
    dependsOn 'lintMDL'
    dependsOn 'lintProselint'
}

task buildGoogleTest(type: Exec) {
    dependsOn 'pullDeps'
    shouldRunAfter 'pullDeps'
    def gtest = "${projectDir.getPath()}/${googletest_location}"
    doFirst { exec { commandLine "mkdir", "${gtest}/build" } }
    doFirst { exec { commandLine "rm", "-rf", "${gtest}/build" } }
    commandLine "g++", "-std=c++11", "-isystem", "${gtest}/include", "-I${gtest}", "-pthread", "-c", "${gtest}/src/gtest-all.cc", "-o", "${gtest}/build/gtest-all.o"
    doLast {
        exec {
            commandLine "ar", "-rv", "${gtest}/build/libgtest.a", "${gtest}/build/gtest-all.o"
        }
    }
}

task pullDeps(type: Exec) {
    doFirst { println 'Updating dependencies' }
    commandLine 'git', 'submodule', 'update', '--init', '--recursive'
}

task deps {
    dependsOn 'pullDeps'
    dependsOn 'buildGoogleTest'
}

// install the rayterm.so library
task install(type: Copy) {
    dependsOn 'build'
    from 'build/lib/rayterm/shared/release'
    into "${System.getProperty("user.home")}/${install_location}"
}

task test {
    dependsOn "clean"
}

tasks.withType(RunTestExecutable) { task ->
    args "--gtest_output=xml:test_detail.xml"
    tasks.test.dependsOn task
    // this may mess up other things
    mustRunAfter "clean"
}
